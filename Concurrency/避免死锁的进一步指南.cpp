#include "iostream"
#include "mutex"
#include "thread"
using namespace std;
// 尽管std::lock,能够帮助你在需要同时获得两个或更多锁的情况下避免死锁,
// 但是如果要分别获取锁,就没用了.在这种情况下,你必须依靠你作为开发人员
// 的戒律,以确保不会得到死锁.这谈何容易,死锁是在编写多线程代码时遇到最
// 令人头疼的问题之一,而且往往无法预测,大部分时间内一切都工作正常.然而,
// 有一些简单的规则可以帮助你写出无死锁的代码.

// 死锁并不仅仅产生于锁定,虽然这是最常见的诱因.你可以通过两个线程来制造
// 死锁,不用锁定,只需令每个线程在std::thread对象上为另一线程调用join().
// 这种简单的循环可以发生在任何地方,一个线程等待另一个线程执行一些动作而
// 另一个线程又同时等待第一个线程,而且这不限于两个线程,三个或更多线程的循
// 环也会导致死锁
// 避免死锁的准则全都可以归结为一个思路,如果有另外一个线程有可能在等待你
// 那你就别等它.这个独特的准则为识别和消除别的线程等待你的可能性提供了方
// 法
// 1 避免嵌套锁
// 第一个思路最为简单,如果你已经持有了一个锁,就别再获取锁.如果你坚持这个
// 准则,光凭使用锁是不可能导致死锁的,因为每个线程仅仅持有一个锁.
// 你仍然会从其他事情(比如线程的相互等待)中得到死锁,但是互斥元锁定可能是
// 死锁最常见的诱因.如果需要获取多个锁,为了避免死锁,就以std::lock的当个
// 动作来执行.
// 2 在持有锁时,避免调用用户提供的代码
// 这是前面一条准则的简单后续,因为代码是用户提供的,你不知道它会做什么,它
// 可能做包括锁在内的任何事情.如果你在持有锁时调用用户提供的代码,并且这段
// 代码获取一个锁,你就违反的避免嵌套锁的准则,可能导致死锁.
// 3 以固定顺序获取锁
// 如果你绝对需要两个或更多的锁,并且不能以std::lock的单个操作取得,次优的
// 做法是在每个线程中以相同的顺序获取它们.
// 4 使用层次锁
// 这其实是定义锁顺序的一个特例.
int main()
{
	thread t1;
	thread t2;
	t1 = thread([&t2] {
		cout << "thread-1 start!" << endl;
		std::chrono::seconds dura(2);
		std::this_thread::sleep_for(dura);
		t2.join();
		cout << "thread-1 finished!" << endl;
	});
	t2 = thread([&t1] {
		cout << "thread-2 start!" << endl;
		std::chrono::seconds dura(2);
		std::this_thread::sleep_for(dura);
		t1.join();
		cout << "thread-2 finished!" << endl;
	});
	system("pause");
	return 0; 
}